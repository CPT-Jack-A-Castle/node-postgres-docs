{"data":{"site":{"siteMetadata":{"title":"node-postgres","docsLocation":"https://github.com/hasura/gatsby-gitbook-boilerplate/tree/master/content"}},"mdx":{"fields":{"id":"7099455d-01c1-5969-8cfd-58b1347bcc44","title":"Data Types","slug":"/features/types"},"code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Data Types\",\n  \"slug\": \"/features/types\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"PostgreSQL has a rich system of supported \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.postgresql.org/docs/9.5/static/datatype.html\"\n  }), \"data types\"), \". node-postgres does its best to support the most common data types out of the box and supplies an extensible type parser to allow for custom type serialization and parsing.\"), mdx(\"h2\", null, \"strings by default\"), mdx(\"p\", null, \"node-postgres will convert a database type to a JavaScript string if it doesn't have a registered type parser for the database type. Furthermore, you can send any type to the PostgreSQL server as a string and node-postgres will pass it through without modifying it in any way. To circumvent the type parsing completely do something like the following.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const queryText = 'select int_col::string, date_col::string, json_col::string from my_table'\\nconst result = await client.query(queryText)\\n\\nconsole.log(result.rows[0]) // will contain the unparsed string value of each column\\n\")), mdx(\"h2\", null, \"type parsing examples\"), mdx(\"h3\", null, \"uuid + json / jsonb\"), mdx(\"p\", null, \"There is no data type in JavaScript for a uuid/guid so node-postgres converts a uuid to a string. JavaScript has great support for JSON and node-postgres converts json/jsonb objects directly into their JavaScript object via \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/brianc/node-pg-types/blob/master/lib/textParsers.js#L193\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"JSON.parse\")), \". Likewise sending an object to the PostgreSQL server via a query from node-postgres, node-posgres will call \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/brianc/node-postgres/blob/e5f0e5d36a91a72dda93c74388ac890fa42b3be0/lib/utils.js#L47\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"JSON.stringify\")), \" on your outbound value, automatically converting it to json for the server.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const createTableText = `\\nCREATE EXTENSION IF NOT EXISTS \\\"pgcrypto\\\";\\n\\nCREATE TEMP TABLE IF NOT EXISTS users (\\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\\n  data JSONB\\n);\\n`\\n// create our temp table\\nawait client.query(createTableText)\\n\\nconst newUser = { email: 'brian.m.carlson@gmail.com' }\\n// create a new user\\nawait client.query('INSERT INTO users(data) VALUES($1)', [newUser])\\n\\nconst { rows } = await client.query('SELECT * FROM users')\\n\\nconsole.log(rows)\\n/*\\noutput:\\n[{\\n  id: 'd70195fd-608e-42dc-b0f5-eee975a621e9',\\n  data: { email: 'brian.m.carlson@gmail.com' }\\n}]\\n*/\\n\")), mdx(\"h3\", null, \"date / timestamp / timestamptz\"), mdx(\"p\", null, \"node-postgres will convert instances of JavaScript date objects into the expected input value for your PostgreSQL server. Likewise, when reading a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"date\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timestamp\"), \", or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"timestamptz\"), \" column value back into JavaScript, node-postgres will parse the value into an instance of a JavaScript \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Date\"), \" object.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const createTableText = `\\nCREATE TEMP TABLE dates(\\n  date_col DATE,\\n  timestamp_col TIMESTAMP,\\n  timestamptz_col TIMESTAMPTZ,\\n);\\n`\\n// create our temp table\\nawait client.query(createTableText)\\n\\n// insert the current time into it\\nconst now = new Date()\\nconst insertText = 'INSERT INTO dates(date_col, timestamp_col, timestamtz_col'\\nawait client.query(insertText, [now, now, now])\\n\\n// read the row back out\\nconst result = await client.query('SELECT * FROM dates')\\n\\nconsole.log(result.rows)\\n// {\\n// date_col: 2017-05-29T05:00:00.000Z,\\n// timestamp_col: 2017-05-29T23:18:13.263Z,\\n// timestamptz_col: 2017-05-29T23:18:13.263Z\\n// }\\n\")), mdx(\"p\", null, \"psql output:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-psql\"\n  }), \"bmc=# select * from dates;\\n  date_col  |      timestamp_col      |      timestamptz_col\\n------------+-------------------------+----------------------------\\n 2017-05-29 | 2017-05-29 18:18:13.263 | 2017-05-29 18:18:13.263-05\\n(1 row)\\n\")), mdx(\"p\", null, \"node-postgres converts \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DATE\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TIMESTAMP\"), \" columns into the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"local\"), \" time of the node process set at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"process.env.TZ\"), \".\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"note: I generally use \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \"TIMESTAMPTZ\"), \" when storing dates; otherwise, inserting a time from a process in one timezone and reading it out in a process in another timezone can cause unexpected differences in the time.\")), mdx(\"div\", {\n    className: \"message is-warning\"\n  }, mdx(\"div\", {\n    className: \"message-body\"\n  }, \"Although PostgreSQL supports microseconds in dates, JavaScript only supports dates to the millisecond precision.  Keep this in mind when you send dates to and from PostgreSQL from node: your milliseconds will be truncated when converting to a JavaScript date object even if they exist in the database.  If you need to preserve them, I recommend using a custom type parser.\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"tableOfContents":{"items":[{"url":"#strings-by-default","title":"strings by default"},{"url":"#type-parsing-examples","title":"type parsing examples","items":[{"url":"#uuid--json--jsonb","title":"uuid + json / jsonb"},{"url":"#date--timestamp--timestamptz","title":"date / timestamp / timestamptz"}]}]},"parent":{"__typename":"File","relativePath":"features/5-types.mdx"},"frontmatter":{"metaTitle":null}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/announcements","title":"Announcements"}}},{"node":{"fields":{"slug":"/","title":"Welcome"}}},{"node":{"fields":{"slug":"/api","title":"API"}}},{"node":{"fields":{"slug":"/features/connecting","title":"Connecting"}}},{"node":{"fields":{"slug":"/features/queries","title":"Queries"}}},{"node":{"fields":{"slug":"/features/types","title":"Data Types"}}},{"node":{"fields":{"slug":"/api/pool","title":"pg.Pool"}}},{"node":{"fields":{"slug":"/api/result","title":"pg.Result"}}},{"node":{"fields":{"slug":"/features/ssl","title":"SSL"}}},{"node":{"fields":{"slug":"/features/native","title":"Native Bindings"}}},{"node":{"fields":{"slug":"/api/cursor","title":"pg.Cursor"}}},{"node":{"fields":{"slug":"/features/pooling","title":"Pooling"}}},{"node":{"fields":{"slug":"/api/types","title":"Types"}}},{"node":{"fields":{"slug":"/features/transactions","title":"Transactions"}}},{"node":{"fields":{"slug":"/guides/project-structure","title":"Suggested Project Structure"}}},{"node":{"fields":{"slug":"/guides/async-express","title":"Express with async/await"}}},{"node":{"fields":{"slug":"/guides/upgrading","title":"Upgrading to 7.0"}}},{"node":{"fields":{"slug":"/api/client","title":"pg.Client"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"7099455d-01c1-5969-8cfd-58b1347bcc44"}}