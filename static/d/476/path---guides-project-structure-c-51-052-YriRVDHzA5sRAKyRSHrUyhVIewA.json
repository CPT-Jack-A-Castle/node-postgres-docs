{"data":{"site":{"siteMetadata":{"title":"node-postgres","docsLocation":"https://github.com/hasura/gatsby-gitbook-boilerplate/tree/master/content"}},"mdx":{"fields":{"id":"06066510-3de6-5c3c-ba2a-b1e3ab92b524","title":"Project Structure","slug":"/guides/project-structure"},"code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Suggested Project Structure\"), mdx(\"p\", null, \"Whenever I am writing a project & using node-postgres I like to create a file within it and make all interactions with the database go through this file.  This serves a few purposes:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Allows my project to adjust to any changes to the node-postgres API without having to trace down all the places I directly use node-postgres in my application.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Allows me to have a single place to put logging and diagnostics around my database.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Allows me to make custom extensions to my database access code & share it throughout the project.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Allows a single place to bootstrap & configure the database.\")), mdx(\"h2\", null, \"example\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"note: I am using callbacks in this example to introduce as few concepts as possible at a time, but the same is doable with promises or async/await\")), mdx(\"p\", null, \"The location doesn't really matter - I've found it usually ends up being somewhat app specific and in line with whatever folder structure conventions you're using.  For this example I'll use an express app structured like so:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"- app.js\\n- index.js\\n- routes/\\n  - index.js\\n  - photos.js\\n  - user.js\\n- db/\\n  - index.js <--- this is where I put data access code\\n\")), mdx(\"p\", null, \"Typically I'll start out my \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"db/index.js\"), \" file like so:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool()\\n\\nmodule.exports = {\\n  query: (text, params, callback) => {\\n    return pool.query(text, params, callback)\\n  }\\n}\\n\")), mdx(\"p\", null, \"That's it.  But now everywhere else in my application instead of requiring \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pg\"), \" directly, I'll require this file.  Here's an example of a route within \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"routes/user.js\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// notice here I'm requiring my database adapter file\\n// and not requiring node-postgres directly\\nconst db = require('../db')\\n\\napp.get('/:id', (req, res, next) => {\\n  db.query('SELECT * FROM users WHERE id = $1', [id], (err, res) => {\\n    if (err) {\\n      return next(err)\\n    }\\n    res.send(res.rows[0])\\n  })\\n})\\n\\n// ... many other routes in this file\\n\")), mdx(\"p\", null, \"Imagine we have lots of routes scattered throughout many files under our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"routes/\"), \" directory.  We now want to go back and log every single query that's executed, how long it took, and the number of rows it returned.  If we had required node-postgres directly in every route file we'd have to go edit every single route - that would take forever & be really error prone!  But thankfully we put our data access into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"db/index.js\"), \".  Let's go add some logging:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool()\\n\\nmodule.exports = {\\n  query: (text, params, callback) => {\\n    const start = Date.now()\\n    return pool.query(text, params, (err, res) => {\\n      const duration = Date.now() - start\\n      console.log('executed query', { text, duration, rows: res.rowCount })\\n      callback(err, res)\\n    })\\n  }\\n}\\n\")), mdx(\"p\", null, \"That was pretty quick! And now all of our queries everywhere in our application are being logged.\"), mdx(\"summary\", null, \"_note: I didn't log the query parameters.  Depending on your application you might be storing encrypted passwords or other sensitive information in your database.  If you log your query parameters you might accidentally log sensitive information.  Every app is different though so do what suits you best!\"), mdx(\"p\", null, \"Now what if we need to check out a client from the pool to run sever queries in a row in a transaction?  We can add another method to our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"db/index.js\"), \" file when we need to do this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool()\\n\\nmodule.exports = {\\n  query: (text, params, callback) {\\n    const start = Date.now()\\n    return pool.query(text, params, (err, res) => {\\n      const duration = Date.now() - start\\n      console.log('executed query', { text, duration, rows: res.rowCount })\\n      callback(err, res)\\n    })\\n  },\\n  getClient: (callback) {\\n    pool.connect((err, client, done) => {\\n      callback(err, client, done)\\n    })\\n  }\\n}\\n\")), mdx(\"p\", null, \" Okay. Great - the simplesting thing that could possibly work.  It seems like one of our routes that checks out a client to run a transaction is forgetting to call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"done\"), \" in some situation! Oh no! We are leaking a client & have hundreds of these routes to go audit.  Good thing we have all our client access going through this single file.  Lets add some deeper diagnostic information here to help us track down where the client leak is happening.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool()\\n\\nmodule.exports = {\\n  query: (text, params, callback) {\\n    const start = Date.now()\\n    return pool.query(text, params, (err, res) => {\\n      const duration = Date.now() - start\\n      console.log('executed query', { text, duration, rows: res.rowCount })\\n      callback(err, res)\\n    })\\n  },\\n  getClient: (callback) {\\n    pool.connect((err, client, done) => {\\n      const query = client.query.bind(client)\\n\\n      // monkey patch the query method to keep track of the last query executed\\n      client.query = () => {\\n        client.lastQuery = arguments\\n        client.query.apply(client, arguments)\\n      }\\n\\n      // set a timeout of 5 seconds, after which we will log this client's last query\\n      const timeout = setTimeout(() => {\\n        console.error('A client has been checked out for more than 5 seconds!')\\n        console.error(`The last executed query on this client was: ${client.lastQuery}`)\\n      }, 5000)\\n\\n      const release = (err) => {\\n        // call the actual 'done' method, returning this client to the pool\\n        done(err)\\n\\n        // clear our timeout\\n        clearTimeout(timeout)\\n\\n        // set the query method back to its old un-monkey-patched version\\n        client.query = query\\n      }\\n\\n      callback(err, client, done)\\n    })\\n  }\\n}\\n\")), mdx(\"p\", null, \"That should hopefully give us enough diagnostic information to track down any leaks.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"tableOfContents":{"items":[{"url":"#suggested-project-structure","title":"Suggested Project Structure","items":[{"url":"#example","title":"example"}]}]},"parent":{"__typename":"File","relativePath":"guides/project-structure.md"},"frontmatter":{"metaTitle":null}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/announcements","title":"Announcements"}}},{"node":{"fields":{"slug":"/api","title":"API"}}},{"node":{"fields":{"slug":"/","title":"Welcome"}}},{"node":{"fields":{"slug":"/features/1-connecting","title":"Connecting"}}},{"node":{"fields":{"slug":"/features/3-pooling","title":"Pooling"}}},{"node":{"fields":{"slug":"/features/4-transactions","title":"Transactions"}}},{"node":{"fields":{"slug":"/features/2-queries","title":"Queries"}}},{"node":{"fields":{"slug":"/features/5-types","title":"Data Types"}}},{"node":{"fields":{"slug":"/features/6-ssl","title":"SSL"}}},{"node":{"fields":{"slug":"/api-docs/1-pool","title":"pg.Pool"}}},{"node":{"fields":{"slug":"/api-docs/2-client","title":"pg.Client"}}},{"node":{"fields":{"slug":"/features/7-native","title":"Native Bindings"}}},{"node":{"fields":{"slug":"/api-docs/4-types","title":"4 Types"}}},{"node":{"fields":{"slug":"/api-docs/3-result","title":"pg.Result"}}},{"node":{"fields":{"slug":"/guides/async-express","title":"Async Express"}}},{"node":{"fields":{"slug":"/api-docs/5-cursor","title":"pg.Cursor"}}},{"node":{"fields":{"slug":"/guides/upgrading","title":"Upgrading"}}},{"node":{"fields":{"slug":"/guides/project-structure","title":"Project Structure"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"06066510-3de6-5c3c-ba2a-b1e3ab92b524"}}