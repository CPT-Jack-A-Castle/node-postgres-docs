{"data":{"site":{"siteMetadata":{"title":"node-postgres","docsLocation":"https://github.com/hasura/gatsby-gitbook-boilerplate/tree/master/content"}},"mdx":{"fields":{"id":"b974d586-70e4-5dc7-a831-07d19ed588ab","title":"pg.Pool","slug":"/api-docs/1-pool"},"code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"pg.Pool\",\n  \"slug\": \"/api/pool\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"new Pool(\", \"[config: object]\", \")\"), mdx(\"p\", null, \"Every field of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"config\"), \" object is entirely optional. The config passed to the pool is also passed to every client instance within the pool when the pool creates that client.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-flow\"\n  }), \"config = {\\n  // all valid client config options are also valid here\\n  // in addition here are the pool specific configuration parameters:\\n\\n  // number of milliseconds to wait before timing out when connecting a new client\\n  // by default this is 0 which means no timeout\\n  connectionTimeoutMillis?: int,\\n\\n  // number of milliseconds a client must sit idle in the pool and not be checked out\\n  // before it is disconnected from the backend and discarded\\n  // default is 10000 (10 seconds) - set to 0 to disable auto-disconnection of idle clients\\n  idleTimeoutMillis?: int,\\n\\n  // maximum number of clients the pool should contain\\n  // by default this is set to 10.\\n  max?: int,\\n}\\n\")), mdx(\"p\", null, \"example to create a new pool with configuration:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool({\\n  host: 'localhost',\\n  user: 'database-user',\\n  max: 20,\\n  idleTimeoutMillis: 30000,\\n  connectionTimeoutMillis: 2000,\\n})\\n\")), mdx(\"h2\", null, \"pool.connect\"), mdx(\"h3\", null, mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"pool.connect(callback: (err?: Error, client: pg.Client, release: releaseCallback) => void) => void\")), mdx(\"p\", null, \"Acquires a client from the pool. If the pool is 'full' and all clients are currently checked out, this will wait in a FIFO queue until a client becomes available by it being released back to the pool. If there are idle clients in the pool it will be returned to the callback on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"process.nextTick\"), \". If the pool is not full a new client will be created & returned to this callback.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool()\\n\\npool.connect((err, client, release) => {\\n  if (err) {\\n    return console.error('Error acquiring client', err.stack)\\n  }\\n  client.query('SELECT NOW()', (err, result) => {\\n    release()\\n    if (err) {\\n      return console.error('Error executing query', err.stack)\\n    }\\n    console.log(result.rows)\\n  })\\n})\\n\")), mdx(\"h3\", null, mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"pool.connect() => Promise<pg.Client>\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool()\\n\\n;(async function() {\\n  const client = await pool.connect()\\n  await client.query('SELECT NOW()')\\n  client.release()\\n})()\\n\")), mdx(\"div\", {\n    className: \"alert alert-warning\"\n  }, \"You \", mdx(\"strong\", null, \"must\"), \" call the \", mdx(\"span\", {\n    className: \"code\"\n  }, \"releaseCallback\"), \" or\", ' ', mdx(\"span\", {\n    className: \"code\"\n  }, \"client.release\"), \" (which points to the \", mdx(\"span\", {\n    className: \"code\"\n  }, \"releaseCallback\"), \") when you are finished with a client. If you forget to release the client then your application will quickly exhaust available, idle clients in the pool and all further calls to \", mdx(\"span\", {\n    className: \"code\"\n  }, \"pool.connect\"), \" will timeout with an error or hang indefinitely if you have \", mdx(\"span\", {\n    className: \"code\"\n  }, \"connectionTimeoutMills\"), \" configured to 0.\"), mdx(\"h2\", null, \"releaseCallback\"), mdx(\"h3\", null, \"release: (err?: Error)\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"releaseCallback\"), \" releases an acquired client back to the pool. If you pass a truthy value in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"err\"), \" position to the callback, instead of releasing the client to the pool, the pool will be instructed to disconnect and destroy this client, leaving a space within itself for a new client.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool()\\nassert(pool.totalCount === 0)\\nassert(pool.idleCount === 0)\\n;(async function() {\\n  const client = await pool.connect()\\n  await client.query('SELECT NOW()')\\n  assert(pool.totalCount === 1)\\n  assert(pool.idleCount === 0)\\n\\n  // tell the pool to destroy this client\\n  client.release(true)\\n  assert(pool.idleCount === 0)\\n  assert(pool.totalCount === 0)\\n})()\\n\")), mdx(\"p\", null, \"Client instances returned from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pool.connect\"), \" will have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"release\"), \" method which will release them from the pool. This is the same method that is passed to the connect callback as the 3rd argument if you're using the pool with callbacks.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool()\\npool.connect((err, client, release) => {\\n  assert(client.release === release)\\n})\\n\")), mdx(\"h2\", null, \"pool.query\"), mdx(\"p\", null, \"Often we only need to run a single query on the database, so as convenience the pool has a method to run a query on the first available idle client and return its result.\"), mdx(\"h3\", null, \"pool.query(callback: (err?: Error, result: pg.Result)) => void\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool()\\n\\npool.query('SELECT $1::text as name', ['brianc'], (err, result) => {\\n  if (err) {\\n    return console.error('Error executing query', err.stack)\\n  }\\n  console.log(result.rows[0].name) // brianc\\n})\\n\")), mdx(\"p\", null, \"Promises are also supported:\"), mdx(\"h3\", null, mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"pool.query() => Promise<pg.Result>\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Pool } = require('pg')\\n\\nconst pool = new Pool()\\n\\npool\\n  .query('SELECT $1::text as name', ['brianc'])\\n  .then(res => console.log(res.rows[0].name)) // brianc\\n  .catch(err => console.error('Error executing query', err.stack))\\n\")), mdx(\"p\", null, \"Notice in the example above no \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"releaseCallback\"), \" was necessary. The pool is doing the acquiring and releasing internally. I find \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pool.query\"), \" to be a handy shortcut in a lot of situations.\"), mdx(\"p\", null, \"Do \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" use pool.query if you need transactional integrity: the pool will dispatch every query passed to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pool.query\"), \" on the first available idle client. Transactions within PostgreSQL are scoped to a single client and so dispatching individual queries within a single transaction across multiple, random clients will cause big problems in your app and not work. For more info please read \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/features/transactions\"\n  }), \"transactions\"), \".\"), mdx(\"h2\", null, \"pool.end\"), mdx(\"p\", null, \"Calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pool.end\"), \" will drain the pool of all active clients, disconnect them, and shut down any internal timers in the pool. It is common to call this at the end of a script using the pool or when your process is attempting to shut down cleanly.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// again both promises and callbacks are supported:\\nconst { Pool } = require('pg')\\n\\nconst pool = new Pool()\\n\\n// either this:\\npool.end(() => {\\n  console.log('pool has ended')\\n})\\n\\n// or this:\\npool.end().then(() => console.log('pool has ended'))\\n\")), mdx(\"h2\", null, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"pool.totalCount: int\")), mdx(\"p\", null, \"The total number of clients existing within the pool.\"), mdx(\"h2\", null, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"pool.idleCount: int\")), mdx(\"p\", null, \"The number of clients which are not checked out but are currently idle in the pool.\"), mdx(\"h2\", null, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"pool.waitingCount: int\")), mdx(\"p\", null, \"The number of queued requests waiting on a client when all clients are checked out. It can be helpful to monitor this number to see if you need to adjust the size of the pool.\"), mdx(\"h2\", null, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"pool.on('connect', (client: Client) => void) => void\")), mdx(\"p\", null, \"Whenever the pool establishes a new client connection to the PostgreSQL backend it will emit the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"connect\"), \" event with the newly connected client. This presents an opportunity for you to run setup commands on a client.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const pool = new Pool()\\npool.on('connect', client => {\\n  client.query('SET DATESTYLE = iso, mdy')\\n})\\n\")), mdx(\"h2\", null, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"pool.on('acquire', (client: Client) => void) => void\")), mdx(\"p\", null, \"Whenever the a client is checked out from the pool the pool will emit the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"acquire\"), \" event with the client that was acquired.\"), mdx(\"h2\", null, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"pool.on('error', (err: Error, client: Client) => void) => void\")), mdx(\"p\", null, \"When a client is sitting idly in the pool it can still emit errors because it is connected to a live backend. If the backend goes down or a network partition is encountered all the idle, connected clients in your application will emit an error \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"through\"), \" the pool's error event emitter. The error listener is passed the error as the first argument and the client upon which the error occurred as the 2nd argument. The client will be automatically terminated and removed from the pool, it is only passed to the error handler in case you want to inspect it.\"), mdx(\"div\", {\n    className: \"message is-danger\"\n  }, mdx(\"div\", {\n    className: \"message-body\"\n  }, \"It is important you add an event listener to the pool to catch errors. Just like other event emitters, if a pool emits an \", mdx(\"span\", {\n    className: \"code\"\n  }, \"error\"), \" event and no listeners are added node will emit an uncaught error and potentially exit.\")), mdx(\"h2\", null, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"pool.on('remove', (client: Client) => void) => void\")), mdx(\"p\", null, \"Whenever a client is closed & removed from the pool the pool will emit the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"remove\"), \" event.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"tableOfContents":{"items":[{"url":"#new-poolconfig-object","title":"new Pool(config: object)"},{"url":"#poolconnect","title":"pool.connect","items":[{"url":"#poolconnectcallback-err-error-client-pgclient-release-releasecallback--void--void","title":"pool.connect(callback: (err?: Error, client: pg.Client, release: releaseCallback) => void) => void"},{"url":"#poolconnect--promisepgclient","title":"pool.connect() => Promise<pg.Client>"}]},{"url":"#releasecallback","title":"releaseCallback","items":[{"url":"#release-err-error","title":"release: (err?: Error)"}]},{"url":"#poolquery","title":"pool.query","items":[{"url":"#poolquerycallback-err-error-result-pgresult--void","title":"pool.query(callback: (err?: Error, result: pg.Result)) => void"},{"url":"#poolquery--promisepgresult","title":"pool.query() => Promise<pg.Result>"}]},{"url":"#poolend","title":"pool.end"},{"url":"#pooltotalcount-int","title":"pool.totalCount: int"},{"url":"#poolidlecount-int","title":"pool.idleCount: int"},{"url":"#poolwaitingcount-int","title":"pool.waitingCount: int"},{"url":"#poolonconnect-client-client--void--void","title":"pool.on('connect', (client: Client) => void) => void"},{"url":"#poolonacquire-client-client--void--void","title":"pool.on('acquire', (client: Client) => void) => void"},{"url":"#poolonerror-err-error-client-client--void--void","title":"pool.on('error', (err: Error, client: Client) => void) => void"},{"url":"#poolonremove-client-client--void--void","title":"pool.on('remove', (client: Client) => void) => void"}]},"parent":{"__typename":"File","relativePath":"api-docs/1-pool.mdx"},"frontmatter":{"metaTitle":null}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/announcements","title":"Announcements"}}},{"node":{"fields":{"slug":"/api-docs/2-client","title":"pg.Client"}}},{"node":{"fields":{"slug":"/","title":"Welcome"}}},{"node":{"fields":{"slug":"/api-docs/3-result","title":"pg.Result"}}},{"node":{"fields":{"slug":"/api","title":"API"}}},{"node":{"fields":{"slug":"/api-docs/4-types","title":"4 Types"}}},{"node":{"fields":{"slug":"/guides/async-express","title":"Async Express"}}},{"node":{"fields":{"slug":"/guides/project-structure","title":"Project Structure"}}},{"node":{"fields":{"slug":"/features/2-queries","title":"Queries"}}},{"node":{"fields":{"slug":"/features/1-connecting","title":"Connecting"}}},{"node":{"fields":{"slug":"/features/5-types","title":"Data Types"}}},{"node":{"fields":{"slug":"/features/7-native","title":"Native Bindings"}}},{"node":{"fields":{"slug":"/guides/upgrading","title":"Upgrading"}}},{"node":{"fields":{"slug":"/api-docs/1-pool","title":"pg.Pool"}}},{"node":{"fields":{"slug":"/features/6-ssl","title":"SSL"}}},{"node":{"fields":{"slug":"/features/3-pooling","title":"Pooling"}}},{"node":{"fields":{"slug":"/api-docs/5-cursor","title":"pg.Cursor"}}},{"node":{"fields":{"slug":"/features/4-transactions","title":"Transactions"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"b974d586-70e4-5dc7-a831-07d19ed588ab"}}