{"data":{"site":{"siteMetadata":{"title":"node-postgres","docsLocation":"https://github.com/hasura/gatsby-gitbook-boilerplate/tree/master/content"}},"mdx":{"fields":{"id":"84734887-9f49-554b-ad36-9cb9ade809b5","title":"pg.Client","slug":"/api/client"},"code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"pg.Client\",\n  \"slug\": \"/api/client\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"new Client(\", \"[config: object]\", \")\"), mdx(\"p\", null, \"Every field of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"config\"), \" object is entirely optional. A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Client\"), \" instance will use \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/features/connecting#environment-variables\"\n  }), \"environment variables\"), \" for all missing values.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-flow\"\n  }), \"config = {\\n  user?: string, // default process.env.PGUSER || process.env.USER\\n  password?: string, //default process.env.PGPASSWORD\\n  database?: string, // default process.env.PGDATABASE || process.env.USER\\n  port?: number, // default process.env.PGPORT\\n  connectionString?: string // e.g. postgres://user:password@host:5432/database\\n  ssl?: any, // passed directly to node.TLSSocket\\n  types?: any, // custom type parsers\\n  statement_timeout: number, // number of milliseconds before a query will time out default is no timeout\\n}\\n\")), mdx(\"p\", null, \"example to create a client with specific connection information:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Client } = require('pg')\\n\\nconst client = new Client({\\n  host: 'my.database-server.com',\\n  port: 5334,\\n  user: 'database-user',\\n  password: 'secretpassword!!',\\n})\\n\")), mdx(\"h2\", null, \"client.connect\"), mdx(\"h3\", null, mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"client.connect(callback: (err: Error) => void) => void\")), mdx(\"p\", null, \"Calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.connect\"), \" with a callback:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Client } = require('pg')\\nconst client = new Client()\\nclient.connect(err => {\\n  if (err) {\\n    console.error('connection error', err.stack)\\n  } else {\\n    console.log('connected')\\n  }\\n})\\n\")), mdx(\"h3\", null, mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"client.connect() => Promise<void>\")), mdx(\"p\", null, \"Calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.connect\"), \" without a callback yields a promise:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Client } = require('pg')\\nconst client = new Client()\\nclient\\n  .connect()\\n  .then(() => console.log('connected'))\\n  .catch(e => console.error('connection error', err.stack))\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"note: connect returning a promise only available in pg@7.0 or above\")), mdx(\"h2\", null, \"client.query\"), mdx(\"h3\", null, mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"client.query\"), \" - text, optional values, and callback.\"), mdx(\"p\", null, \"Passing query text, optional query parameters, and a callback to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" results in a type-signature of:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-flow\"\n  }), \"client.query(\\n  text: string,\\n  values?: Array<mixed>,\\n  callback: (err: Error, result: Result) => void\\n) => void\\n\")), mdx(\"p\", null, \"That is a kinda gross type signature but it translates out to this:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Plain text query with a callback:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Client } = require('pg').Client\\nconst client = new Client()\\nclient.connect()\\nclient.query('SELECT NOW()', (err, res) => {\\n  if (err) throw err\\n  console.log(res)\\n  client.end()\\n})\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Parameterized query with a callback:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Client } = require('pg').Client\\nconst client = new Client()\\nclient.connect()\\nclient.query('SELECT $1::text as name', ['brianc'], (err, res) => {\\n  if (err) throw err\\n  console.log(res)\\n  client.end()\\n})\\n\")), mdx(\"h3\", null, mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"client.query\"), \" - text, optional values: Promise\"), mdx(\"p\", null, \"If you call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" with query text and optional parameters but \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"don't\"), \" pass a callback, then you will receive a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Promise\"), \" for a query result.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-flow\"\n  }), \"client.query(\\n  text: string,\\n  values?: Array<mixed>\\n) => Promise<Result>\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Plain text query with a promise\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Client } = require('pg').Client\\nconst client = new Client()\\nclient.connect()\\nclient\\n  .query('SELECT NOW()')\\n  .then(result => console.log(result))\\n  .catch(e => console.error(e.stack))\\n  .then(() => client.end())\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Parameterized query with a promise\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const { Client } = require('pg').Client\\nconst client = new Client()\\nclient.connect()\\nclient\\n  .query('SELECT $1::text as name', ['brianc'])\\n  .then(result => console.log(result))\\n  .catch(e => console.error(e.stack))\\n  .then(() => client.end())\\n\")), mdx(\"h3\", null, mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"client.query(config: QueryConfig, callback: (err?: Error, result?: Result) => void) => void\")), mdx(\"h3\", null, mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"client.query(config: QueryConfig) => Promise<Result>\")), mdx(\"p\", null, \"You can pass an object to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" with the signature of:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-flow\"\n  }), \"interface QueryConfig {\\n  // the raw query text\\n  text: string;\\n\\n  // an array of query parameters\\n  values?: Array<mixed>;\\n\\n  // name of the query - used for prepared statements\\n  name?: string;\\n\\n  // by default rows come out as a key/value pair for each row\\n  // pass the string 'array' here to receive rows as an array of values\\n  rowMode?: string;\\n\\n  // custom type parsers just for this query result\\n  types?: Types;\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"client.query with a QueryConfig and a callback\")), mdx(\"p\", null, \"If you pass a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" parameter to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" method, the client will create a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/features/queries#prepared-statements\"\n  }), \"prepared statement\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const query = {\\n  name: 'get-name',\\n  text: 'SELECT $1::text',\\n  values: ['brianc'],\\n  rowMode: 'array',\\n}\\n\\nclient.query(query, (err, res) => {\\n  if (err) {\\n    console.error(err.stack)\\n  } else {\\n    console.log(res.rows) // ['brianc']\\n  }\\n})\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"client.query with a QueryConfig and a Promise\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const query = {\\n  name: 'get-name',\\n  text: 'SELECT $1::text',\\n  values: ['brianc'],\\n  rowMode: 'array',\\n}\\n\\n// promise\\nclient\\n  .query(query)\\n  .then(res => {\\n    console.log(res.rows) // ['brianc']\\n  })\\n  .catch(e => {\\n    console.error(e.stack)\\n  })\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"client.query with a \", mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"Submittable\"))), mdx(\"p\", null, \"If you pass an object to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" and the object has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".submit\"), \" function on it, the client will pass it's PostgreSQL server connection to the object and delegate query dispatching to the supplied object. This is an advanced feature mostly intended for library authors. It is incidentally also currently how the callback and promise based queries above are handled internally, but this is subject to change. It is also how \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/brianc/node-pg-cursor\"\n  }), \"pg-cursor\"), \" and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/brianc/node-pg-query-stream\"\n  }), \"pg-query-stream\"), \" work.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const Query = require('pg').Query\\nconst query = new Query('select $1::text as name', ['brianc'])\\n\\nconst result = client.query(query)\\n\\nassert(query === result) // true\\n\\nquery.on('row', row => {\\n  console.log('row!', row) // { name: 'brianc' }\\n})\\nquery.on('end', () => {\\n  console.log('query done')\\n})\\nquery.on('error', err => {\\n  console.error(err.stack)\\n})\\n\")), mdx(\"hr\", null), mdx(\"h2\", null, \"client.end\"), mdx(\"h3\", null, \"client.end(cb?: (err?: Error) => void) => void\"), mdx(\"p\", null, \"Disconnects the client from the PostgreSQL server.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"client.end(err => {\\n  console.log('client has disconnected')\\n  if (err) {\\n    console.log('error during disconnection', err.stack)\\n  }\\n})\\n\")), mdx(\"h3\", null, mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"client.end() => Promise<void>\")), mdx(\"p\", null, \"Calling end without a callback yields a promise:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"client\\n  .end()\\n  .then(() => console.log('client has disconnected'))\\n  .catch(err => console.error('error during disconnection', err.stack))\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"note: end returning a promise is only available in pg7.0 and above\")), mdx(\"h2\", null, \"events\"), mdx(\"h3\", null, \"client.on('error', (err: Error) => void) => void\"), mdx(\"p\", null, \"When the client is in the process of connecting, dispatching a query, or disconnecting it will catch and foward errors from the PostgreSQL server to the respective \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.connect\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.end\"), \" callback/promise; however, the client maintains a long-lived connection to the PostgreSQL back-end and due to network partitions, back-end crashes, fail-overs, etc the client can (and over a long enough time period \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"will\"), \") eventually be disconnected while it is idle. To handle this you may want to attach an error listener to a client to catch errors. Here's a contrived example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const client = new pg.Client()\\nclient.connect()\\n\\nclient.on('error', err => {\\n  console.error('something bad has happened!', err.stack)\\n})\\n\\n// walk over to server, unplug network cable\\n\\n// process output: 'something bad has happened!' followed by stacktrace :P\\n\")), mdx(\"h3\", null, \"client.on('end') => void\"), mdx(\"p\", null, \"When the client disconnects from the PostgreSQL server it will emit an end event once.\"), mdx(\"h3\", null, \"client.on('notification', (notification: Notification) => void) => void\"), mdx(\"p\", null, \"Used for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"listen/notify\"), \" events:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-flow\"\n  }), \"type Notification {\\n  processId: int,\\n  channel: string,\\n  payload?: string\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const client = new pg.Client()\\nclient.connect()\\n\\nclient.query('LISTEN foo')\\n\\nclient.on('notification', msg => {\\n  console.log(msg.channel) // foo\\n  console.log(msg.payload) // bar!\\n})\\n\\nclient.query(`NOTIFY foo, 'bar!'`)\\n\")), mdx(\"h3\", null, \"client.on('notice', (notice: String) => void) => void\"), mdx(\"p\", null, \"Used to log out \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.postgresql.org/docs/9.6/static/plpgsql-errors-and-messages.html\"\n  }), \"notice messages\"), \" from the PostgreSQL server.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"client.on('notice', msg => console.warn('notice:', msg))\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"tableOfContents":{"items":[{"url":"#new-clientconfig-object","title":"new Client(config: object)"},{"url":"#clientconnect","title":"client.connect","items":[{"url":"#clientconnectcallback-err-error--void--void","title":"client.connect(callback: (err: Error) => void) => void"},{"url":"#clientconnect--promisevoid","title":"client.connect() => Promise<void>"}]},{"url":"#clientquery","title":"client.query","items":[{"url":"#clientquery---text-optional-values-and-callback","title":"client.query - text, optional values, and callback."},{"url":"#clientquery---text-optional-values-promise","title":"client.query - text, optional values: Promise"},{"url":"#clientqueryconfig-queryconfig-callback-err-error-result-result--void--void","title":"client.query(config: QueryConfig, callback: (err?: Error, result?: Result) => void) => void"},{"url":"#clientqueryconfig-queryconfig--promiseresult","title":"client.query(config: QueryConfig) => Promise<Result>"}]},{"url":"#clientend","title":"client.end","items":[{"url":"#clientendcb-err-error--void--void","title":"client.end(cb?: (err?: Error) => void) => void"},{"url":"#clientend--promisevoid","title":"client.end() => Promise<void>"}]},{"url":"#events","title":"events","items":[{"url":"#clientonerror-err-error--void--void","title":"client.on('error', (err: Error) => void) => void"},{"url":"#clientonend--void","title":"client.on('end') => void"},{"url":"#clientonnotification-notification-notification--void--void","title":"client.on('notification', (notification: Notification) => void) => void"},{"url":"#clientonnotice-notice-string--void--void","title":"client.on('notice', (notice: String) => void) => void"}]}]},"parent":{"__typename":"File","relativePath":"api/2-client.mdx"},"frontmatter":{"metaTitle":null}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/guides","title":"Guides"}}},{"node":{"fields":{"slug":"/features","title":"Features"}}},{"node":{"fields":{"slug":"/announcements","title":"Announcements"}}},{"node":{"fields":{"slug":"/api","title":"API"}}},{"node":{"fields":{"slug":"/api/pool","title":"pg.Pool"}}},{"node":{"fields":{"slug":"/","title":"Welcome"}}},{"node":{"fields":{"slug":"/api/types","title":"Types"}}},{"node":{"fields":{"slug":"/api/result","title":"pg.Result"}}},{"node":{"fields":{"slug":"/guides/project-structure","title":"Suggested Project Structure"}}},{"node":{"fields":{"slug":"/guides/upgrading","title":"Upgrading to 7.0"}}},{"node":{"fields":{"slug":"/guides/async-express","title":"Express with async/await"}}},{"node":{"fields":{"slug":"/features/connecting","title":"Connecting"}}},{"node":{"fields":{"slug":"/features/queries","title":"Queries"}}},{"node":{"fields":{"slug":"/features/transactions","title":"Transactions"}}},{"node":{"fields":{"slug":"/features/pooling","title":"Pooling"}}},{"node":{"fields":{"slug":"/features/types","title":"Data Types"}}},{"node":{"fields":{"slug":"/features/ssl","title":"SSL"}}},{"node":{"fields":{"slug":"/api/cursor","title":"pg.Cursor"}}},{"node":{"fields":{"slug":"/api/client","title":"pg.Client"}}},{"node":{"fields":{"slug":"/features/native","title":"Native Bindings"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"84734887-9f49-554b-ad36-9cb9ade809b5"}}