{"data":{"site":{"siteMetadata":{"title":"node-postgres","docsLocation":"https://github.com/hasura/gatsby-gitbook-boilerplate/tree/master/content"}},"mdx":{"fields":{"id":"cd8db9af-41c3-5cc1-9416-6164f83a4eb4","title":"Queries","slug":"/features/2-queries"},"code":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Queries\",\n  \"slug\": \"/features/queries\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The api for executing queries supports both callbacks and promises. I'll provide an example for both \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"styles\"), \" here. For the sake of brevity I am using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" method instead of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pool.query\"), \" method - both methods support the same API. In fact, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pool.query\"), \" delegates directly to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" internally.\"), mdx(\"h2\", null, \"Text only\"), mdx(\"p\", null, \"If your query has no parameters you do not need to include them to the query method:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// callback\\nclient.query('SELECT NOW() as now', (err, res) => {\\n  if (err) {\\n    console.log(err.stack)\\n  } else {\\n    console.log(res.rows[0])\\n  }\\n})\\n\\n// promise\\nclient\\n  .query('SELECT NOW() as now')\\n  .then(res => console.log(res.rows[0]))\\n  .catch(e => console.error(e.stack))\\n\")), mdx(\"h2\", null, \"Parameterized query\"), mdx(\"p\", null, \"If you are passing parameters to your queries you will want to avoid string concatenating parameters into the query text directly. This can (and often does) lead to sql injection vulnerabilities. node-postgres supports paramterized queries, passing your query text \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"unaltered\"), \" as well as your parameters to the PostgreSQL server where the parameters are safely substituted into the query with battle-tested parameter substitution code within the server itself.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const text = 'INSERT INTO users(name, email) VALUES($1, $2) RETURNING *'\\nconst values = ['brianc', 'brian.m.carlson@gmail.com']\\n\\n// callback\\nclient.query(text, values, (err, res) => {\\n  if (err) {\\n    console.log(err.stack)\\n  } else {\\n    console.log(res.rows[0])\\n    // { name: 'brianc', email: 'brian.m.carlson@gmail.com' }\\n  }\\n})\\n\\n// promise\\nclient\\n  .query(text, values)\\n  .then(res => {\\n    console.log(res.rows[0])\\n    // { name: 'brianc', email: 'brian.m.carlson@gmail.com' }\\n  })\\n  .catch(e => console.error(e.stack))\\n\\n// async/await\\ntry {\\n  const res = await pool.query(text, values)\\n  console.log(res.rows[0])\\n  // { name: 'brianc', email: 'brian.m.carlson@gmail.com' }\\n} catch (err) {\\n  console.log(err.stack)\\n}\\n\")), mdx(\"h2\", null, \"Query config object\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pool.query\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \" both support taking a config object as an argument instead of taking a string and optional array of parameters. The same example above could also be performed like so:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const query = {\\n  text: 'INSERT INTO users(name, email) VALUES($1, $2)',\\n  values: ['brianc', 'brian.m.carlson@gmail.com'],\\n}\\n\\n// callback\\nclient.query(query, (err, res) => {\\n  if (err) {\\n    console.log(err.stack)\\n  } else {\\n    console.log(res.rows[0])\\n  }\\n})\\n\\n// promise\\nclient\\n  .query(query)\\n  .then(res => console.log(res.rows[0]))\\n  .catch(e => console.error(e.stack))\\n\")), mdx(\"p\", null, \"The query config object allows for a few more advanced scenarios:\"), mdx(\"h3\", null, \"Prepared statements\"), mdx(\"p\", null, \"PostgreSQL has the concept of a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.postgresql.org/docs/9.3/static/sql-prepare.html\"\n  }), \"prepared statement\"), \". node-postgres supports this by supplying a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" parameter to the query config object. If you supply a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" parameter the query execution plan will be cached on the PostgreSQL server on a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"per connection basis\"), \". This means if you use two different connections each will have to parse & plan the query once. node-postgres handles this transparently for you: a client only requests a query to be parsed the first time that particular client has seen that query name:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const query = {\\n  // give the query a unique name\\n  name: 'fetch-user',\\n  text: 'SELECT * FROM user WHERE id = $1',\\n  values: [1],\\n}\\n\\n// callback\\nclient.query(query, (err, res) => {\\n  if (err) {\\n    console.log(err.stack)\\n  } else {\\n    console.log(res.rows[0])\\n  }\\n})\\n\\n// promise\\nclient\\n  .query(query)\\n  .then(res => console.log(res.rows[0]))\\n  .catch(e => console.error(e.stack))\\n\")), mdx(\"p\", null, \"In the above example the first time the client sees a query with the name \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'fetch-user'\"), \" it will send a 'parse' request to the PostgreSQL server & execute the query as normal. The second time, it will skip the 'parse' request and send the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"name\"), \" of the query to the PostgreSQL server.\"), mdx(\"div\", {\n    className: \"message is-warning\"\n  }, mdx(\"div\", {\n    className: \"message-body\"\n  }, \"Be careful not to fall into the trap of premature optimization.  Most of your queries will likely not benefit much, if at all, from using prepared statements.  This is a somewhat \\\"power user\\\" feature of PostgreSQL that is best used when you know how to use it - namely with very complex queries with lots of joins and advanced operations like union and switch statements.  I rarely use this feature in my own apps unless writing complex aggregate queries for reports and I know the reports are going to be executed very frequently.\")), mdx(\"h3\", null, \"Row mode\"), mdx(\"p\", null, \"By default node-postgres reads rows and collects them into JavaScript objects with the keys matching the column names and the values matching the corresponding row value for each column. If you do not need or do not want this behavior you can pass \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rowMode: 'array'\"), \" to a query object. This will inform the result parser to bypass collecting rows into a JavaScript object, and instead will return eacho row as an array of values.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const query = {\\n  text: 'SELECT $1::text as first_name, select $2::text as last_name',\\n  values: ['Brian', 'Carlson'],\\n  rowMode: 'array',\\n}\\n\\n// callback\\nclient.query(query, (err, res) => {\\n  if (err) {\\n    console.log(err.stack)\\n  } else {\\n    console.log(res.fields.map(f => field.name)) // ['first_name', 'last_name']\\n    console.log(res.rows[0]) // ['Brian', 'Carlson']\\n  }\\n})\\n\\n// promise\\nclient\\n  .query(query)\\n  .then(res => {\\n    console.log(res.fields.map(f => field.name)) // ['first_name', 'last_name']\\n    console.log(res.rows[0]) // ['Brian', 'Carlson']\\n  })\\n  .catch(e => console.error(e.stack))\\n\")), mdx(\"h3\", null, \"Types\"), mdx(\"p\", null, \"You can pass in a custom set of type parsers to use when parsing the results of a particular query. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"types\"), \" property must conform to the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/api/types\"\n  }), \"Types\"), \" API. Here is an example in which every value is returned as a string:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const query = {\\n  text: 'SELECT * from some_table',\\n  types: {\\n    getTypeParser: () => val => val,\\n  },\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"tableOfContents":{"items":[{"url":"#text-only","title":"Text only"},{"url":"#parameterized-query","title":"Parameterized query"},{"url":"#query-config-object","title":"Query config object","items":[{"url":"#prepared-statements","title":"Prepared statements"},{"url":"#row-mode","title":"Row mode"},{"url":"#types","title":"Types"}]}]},"parent":{"__typename":"File","relativePath":"features/2-queries.mdx"},"frontmatter":{"metaTitle":null}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/announcements","title":"Announcements"}}},{"node":{"fields":{"slug":"/","title":"Welcome"}}},{"node":{"fields":{"slug":"/guides/project-structure","title":"Project Structure"}}},{"node":{"fields":{"slug":"/guides/async-express","title":"Async Express"}}},{"node":{"fields":{"slug":"/guides/upgrading","title":"Upgrading"}}},{"node":{"fields":{"slug":"/features/1-connecting","title":"Connecting"}}},{"node":{"fields":{"slug":"/features/2-queries","title":"Queries"}}},{"node":{"fields":{"slug":"/features/3-pooling","title":"Pooling"}}},{"node":{"fields":{"slug":"/features/4-transactions","title":"Transactions"}}},{"node":{"fields":{"slug":"/features/5-types","title":"Data Types"}}},{"node":{"fields":{"slug":"/features/6-ssl","title":"SSL"}}},{"node":{"fields":{"slug":"/features/7-native","title":"Native Bindings"}}},{"node":{"fields":{"slug":"/api","title":"API"}}},{"node":{"fields":{"slug":"/api-docs/1-pool","title":"pg.Pool"}}},{"node":{"fields":{"slug":"/api-docs/cursor","title":"pg.Cursor"}}},{"node":{"fields":{"slug":"/api-docs/types","title":"Types"}}},{"node":{"fields":{"slug":"/api-docs/result","title":"Result"}}},{"node":{"fields":{"slug":"/api-docs/client","title":"pg.Client"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"cd8db9af-41c3-5cc1-9416-6164f83a4eb4"}}